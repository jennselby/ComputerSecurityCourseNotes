<h1>Authorization</h1>
<p>In computer security, we often talk about auth, which can expand to either authentication or authorization.</p>
<p>Thus far, we've really only talked about <strong>authentication</strong>, establishing an entity's identity through their possession of some secret information (password, private key of a asymmetric cryptography key pair, fingerprint pattern, etc.). An entity might be a human, a device, a program (called by a user or another program) -- anything that might be accessing parts of your system.</p>
<p><strong>Authorization</strong> is about deciding what an entity should be allowed to do once we know who they are or what group they are part of. There are many different authorization ideas and systems. They are typically fairly tied to specific applications, unlike authentication systems which tend to be more easily used by any type of program. Authorization is about giving specific <strong>permissions</strong> or <strong>privileges</strong> to specific entities. This is sometimes done through <strong>ACLs</strong>, Access Control Lists.</p>
<p>There are a few guiding principles to think about when designing the authorization for your particular use case.</p>
<ol>
    <li>
        <p><strong>Separate privileges as much as possible and run with the least privilege possible.</strong> The more things an entity has access to, the more opportunities they, or someone who has manage to gain control of their identity, have to attack the system.</p>
        <p>Does your webserver need to run as root or as your user, both of whom have access to things the webserver does not need, or could you create a less privileged user to run it? Because ports 80 and 443, the standard ports for web servers, can only be accessed by superusers on UNIX-based systems, many sites are served on a higher port number so that the server does not need to run as root. Another script with root access has the sole job of forwarding the traffic from the server port to 80 or 443.</p>
        <p>As another example, Mobile OSes have very specific permissions so that apps can be given only the ones they need and no others (e.g. <a target="_blank" href="https://developer.apple.com/design/human-interface-guidelines/ios/app-architecture/requesting-permission/">iOS</a>, <a target="_blank" href="https://developer.android.com/reference/android/Manifest.permission.html">Android</a>). Similarly, some Linux systems have <a target="_blank" href="https://wiki.archlinux.org/index.php/Capabilities">capabilities</a> that can be given to programs rather than full root access.</p>
        <p>Note that this is a balance! If two privileges are almost always used together, it might not make sense to make your users always have to ask for both, possibly leading to users not being able to do what they need to do if the programmer has obtained one permission but forgotten the other. Don't split things up unnecessarily.</p>
    </li>
    <li>
        <p><strong>If asking a human to authorize an action, make it clear what they are authorizing.</strong> If users don't understand what you are asking, they may end up just not doing what they originally wanted to do, or (even worse) they may begin ignoring or turning off your security.</p>
        <p>Early on, <a target="_blank" href="https://www.howtogeek.com/177711/ios-has-app-permissions-too-and-theyre-arguably-better-than-androids/">Android permissions were often confusing and scary for users</a>, because it was hard to understand why apps would need certain permissions when installing them. Fortunately in more recent versions, permissions work as they long have in iOS, with authorization requested when the app needs it rather than at install time. <a target="_blank" href="http://lifehacker.com/230866/windows-vista-tip--disable-annoying-need-your-permission-to-continue--prompts">Windows Vista had a similar problem</a>, frequently asking users to give it permission to run scripts with names like asedt6y1es.exe, causing many users to turn that off those prompts entirely, which was sort of like telling OSX to just run everything with sudo.</p>
    </li>
    <li>
        <p><strong>Check authentication and authorization at every entry point.</strong> It is usually fairly easy to remember to check at the beginning of a system running to see who is running it and what permissions they have. In something like a web server, however, an entity might enter at any URL. Frequently, people have made the mistake of thinking that since the my.example.com/admin link was only on the home pages of admin accounts when the user was logged in, that only admins would access it. However, attackers might think to try that URL directly (a URL interpretation attack), so that page also needs to check that the user is logged into an account with admin permissions.</p>
    </li>
    <li>
        <p><strong>Be careful about ordering allow and deny directives.</strong> Many systems are allow-only: either the entity has been given explicit access, or they can't use the resource. In other cases, you can specify entities that you want to deny, giving everyone else permission.</p>
        <p>Sometimes, these allow and deny lists are read in order: I might deny all students access to my pages teaching people how to hack systems, and allow students in my computer security class. Since the allow comes second, it overrides the deny access just for the students in my class. If I put the lines in the other way around, no students would have access. <a target="_blank" href="https://www.digitalocean.com/community/tutorials/iptables-essentials-common-firewall-rules-and-commands">Firewall systems like iptables work this way when going through accept and drop rules</a>. In other systems, for instance <a target="_blank" href="http://docstore.mik.ua/orelly/linux/apache/ch05_06.htm">Apache directives</a>, allow and deny are processed separately, so that my security class would get access no matter the order of those two control lines, because denies are always processed first.</p>
        <p>If security is a priority for the system you are working on, it is almost always better to deny by default and only allow a small set of specific people or groups rather than to allow by default and deny some specific people or groups.</p>
    </li>
</ol>

<h2>Authorization Exercises</h2>

<p>Respond to at least one of the authorization-related prompts below. Take notes as you do your research.</p>

<ul>
    <li>On UNIX-based systems like OSX, directory and file permissions are generally made up of three groups of three: read, write, and execute permissions for the individual owner, the group owner, and everyone else. You can view the permissions in Terminal with "ls -l" and change the permissions in Terminal with <a target="_blank" href="https://www.computerhope.com/unix/uchmod.htm">chmod</a>. Create a test file and see what permissions it is given by default, then try changing the permissions on it. Take a look at the permissions of some of the directories and files on your computer. Do they make sense to you? Why do you think they have the permissions they do? <strong>Optional coding extension</strong>: Write a script to find any files in your home directory (your folder in /Users/) that are writeable by someone other than you. Do these permissions seem safe to you?</li>
    <li>Some programs <a target="_blank" href="http://linuxg.net/how-to-set-the-setuid-and-setgid-bit-for-files-in-linux-and-unix/">can be set to execute with the privileges of the file owner rather than the user who is running the program</a>. Why do you think this might be useful? Why is it dangerous?</li>
    <li>When you type "sudo" at the Terminal, you are telling the program to run as the superuser, AKA root AKA Admin. Do some research to find some things that the superuser can do that a normal user cannot.</li>
    <li><a target="_blank" href="https://ist.njit.edu/afs-permissions">AFS has more fine-grained permissions than the standard UNIX filesystem</a>. Instead of rwx (read, write, execute), it has rlidwka (read, lookup, insert, delete, write, lock, administer). Come up with scenarios where you might want to have this level of control instead of being limited to the UNIX permissions.</li>
    <li>Look at the permissions that some of the apps have on your phone. Explain why they might need these permissions.</li>
    <li>Find examples of security breaches that resulted at least in part because programmers had made mistakes and not followed our Authorization principles.</li>
    <li>Pick an example website or app and list some pages where they should be checking to make sure the user should be able to access that page. <strong>Optional coding extension</strong>: Find a tutorial about how to add authentication to an app (<a target="_blank" href="https://www.robinwieruch.de/complete-firebase-authentication-react-tutorial">this, for example</a>) and then add some pages where you explicitly check that the user should be able to access them.</li>
</ul>
