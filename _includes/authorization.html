<h1>Authorization</h1>
<p>In computer security, we often talk about auth, which can expand to either authentication or authorization.</p>
<p>Thus far, we've really only talked about <strong>authentication</strong>, establishing an entity's identity through their possession of some secret information (password, private key of a asymmetric cryptography key pair, fingerprint pattern, etc.). An entity might be a human, a device, a program (called by a user or another program) -- anything that might be accessing parts of your system.</p>
<p><strong>Authorization</strong> is about deciding what an entity should be allowed to do once we know who they are or what group they are part of. There are many different authorization ideas and systems. They are typically fairly tied to specific applications, unlike authentication systems which tend to be more easily used by any type of program. Authorization is about giving specific <strong>permissions</strong> or <strong>privileges</strong> to specific entities. This is sometimes done through <strong>ACLs</strong>, Access Control Lists.</p>
<p>There are a few guiding principles to think about when designing the authorization for your particular use case.</p>
<ol>
    <li>
        <p><strong>Separate privileges as much as possible and run with the least privilege possible.</strong> The more things an entity has access to, the more opportunities they, or someone who has manage to gain control of their identity, have to attack the system.</p>
        <p>Does your webserver need to run as root or as your user, both of whom have access to things the webserver does not need, or could you create a less privileged user to run it? Because ports 80 and 443, the standard ports for web servers, can only be accessed by superusers on UNIX-based systems, many sites are served on a higher port number so that the server does not need to run as root. Another script with root access has the sole job of forwarding the traffic from the server port to 80 or 443.</p>
        <p>As another example, Mobile OSes have very specific permissions so that apps can be given only the ones they need and no others (e.g. <a target="_blank" href="https://developer.apple.com/design/human-interface-guidelines/ios/app-architecture/requesting-permission/">iOS</a>, <a target="_blank" href="https://developer.android.com/reference/android/Manifest.permission.html">Android</a>). Similarly, some Linux systems have <a target="_blank" href="https://wiki.archlinux.org/index.php/Capabilities">capabilities</a> that can be given to programs rather than full root access.</p>
        <p>Note that this is a balance! If two privileges are almost always used together, it might not make sense to make your users always have to ask for both, possibly leading to users not being able to do what they need to do if the programmer has obtained one permission but forgotten the other. Don't split things up unnecessarily.</p>
    </li>
    <li>
        <p><strong>If asking a human to authorize an action, make it clear what they are authorizing.</strong> If users don't understand what you are asking, they may end up just not doing what they originally wanted to do, or (even worse) they may begin ignoring or turning off your security.</p>
        <p>Early on, <a target="_blank" href="https://www.howtogeek.com/177711/ios-has-app-permissions-too-and-theyre-arguably-better-than-androids/">Android permissions were often confusing and scary for users</a>, because it was hard to understand why apps would need certain permissions when installing them. Fortunately in more recent versions, permissions work as they long have in iOS, with authorization requested when the app needs it rather than at install time. <a target="_blank" href="http://lifehacker.com/230866/windows-vista-tip--disable-annoying-need-your-permission-to-continue--prompts">Windows Vista had a similar problem</a>, frequently asking users to give it permission to run scripts with names like asedt6y1es.exe, causing many users to turn that off those prompts entirely, which was sort of like telling OSX to just run everything with sudo.</p>
    </li>
    <li>
        <p><strong>Check authentication and authorization at every entry point.</strong> It is usually fairly easy to remember to check at the beginning of a system running to see who is running it and what permissions they have. In something like a web server, however, an entity might enter at any URL. Frequently, people have made the mistake of thinking that since the my.example.com/admin link was only on the home pages of admin accounts when the user was logged in, that only admins would access it. However, attackers might think to try that URL directly (a URL interpretation attack), so that page also needs to check that the user is logged into an account with admin permissions.</p>
    </li>
    <li>
        <p><strong>Be careful about ordering allow and deny directives.</strong> Many systems are allow-only: either the entity has been given explicit access, or they can't use the resource. In other cases, you can specify entities that you want to deny, giving everyone else permission.</p>
        <p>Sometimes, these allow and deny lists are read in order: I might deny all students access to my pages teaching people how to hack systems, and allow students in my computer security class. Since the allow comes second, it overrides the deny access just for the students in my class. If I put the lines in the other way around, no students would have access. <a target="_blank" href="https://www.digitalocean.com/community/tutorials/iptables-essentials-common-firewall-rules-and-commands">Firewall systems like iptables work this way when going through accept and drop rules</a>. In other systems, for instance <a target="_blank" href="http://docstore.mik.ua/orelly/linux/apache/ch05_06.htm">Apache directives</a>, allow and deny are processed separately, so that my security class would get access no matter the order of those two control lines, because denies are always processed first.</p>
        <p>If security is a priority for the system you are working on, it is almost always better to deny by default and only allow a small set of specific people or groups rather than to allow by default and deny some specific people or groups.</p>
    </li>
</ol>
