<h2>Specially Crafted Files</h2>
<p>This example comes from the book <a target="_blank" href="https://www.goodreads.com/book/show/12746081-a-bug-hunter-s-diary?from_search=true"><em>A Bug Hunter's Diary </em>by Tobias Klein</a>[1].</p>
<p>This vulnerability is less common than the ones we've studied so far, but it provides an interesting look into how computers work and how sometimes relatively straightforward errors can become dangerous security risks.</p>
<p>The vulnerability happens through something you might not have thought of as user input: a file. Remember, files are generally coming from the user, so you cannot trust them! They should be treated like any other user input.</p>
<p>In the case described in the book, the code reading in a media (audio/video) file took metadata about buffer sizes from the file and stored them in signed integers. A <strong>signed integer</strong> is one that can be negative or positive. <strong>Unsigned integers</strong> can only be positive, and are typically what you want to use for sizes. In a signed integer, the highest bit is the one that specifies whether the number is positive (if the bit is zero) or negative (if the bit is one). For a one-byte number, 255 would be 255 as an unsigned byte, but -1 as a signed byte. For more information read about <a target="_blank" href="https://www.cs.cornell.edu/~tomf/notes/cps104/twoscomp.html">Two's Complement</a> numbers. Putting in a size for the buffer that is big enough to set the high bit of the integer means that the buffer now has a negative size. A negative number is going to be less than whatever the max size of the buffer is, so any checking of the buffer size is defeated.</p>
<p>This negative number trick allowed the user to overwrite multiple areas of memory with information they put in the specially created file. Since some of this memory contained pointers to the next block of code, the user could now execute whatever code they want.</p>
<p>[1] Chapter 4, "Null Pointer FTW" pages 51-70</p>
