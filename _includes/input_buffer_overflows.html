<h2>Buffer Overflows</h2>
<p>A <strong>buffer</strong> is a certain amount of space that has been allocated in memory.</p>
<p>I might, for instance, need to hold some messages as they come in to my server, until I have time to process them. If each message is 50 bytes, and I ask for a buffer of 1000 bytes (50 * 20), I am OK if I have up to 20 messages waiting.</p>
<p>What if I get up to 21? I should have something in my code that notices that the buffer is full and just ignores the message or deletes an older one to make space for it. What if I forgot to do that or I am so confident I would never have that many messages backed up that I don't bother to check? Many programming languages would throw an error if I attempt to store something at position 1001 in the buffer. While this is not a great outcome (it could result in a denial of service if it causes my server to go down), the damage is fairly limited.</p>
<p>But what about languages that don't check if the index I asked for actually exists in my buffer? The <a target="_blank" href="http://www.learn-c.org/">C language</a>, for instance, does not have many extra features or failsafes, which can make it easier to write fast code since it avoids the overhead of additional checking, but can also make it easier to write unsafe code. In C, I can ask for a certain amount of memory to be set aside for my buffer, and I get back a <a target="_blank" href="http://www.learn-c.org/en/Pointers">pointer</a> -- the address of the beginning of the memory for my buffer -- and that is it. It is entirely up to me, the programmer, to keep track of where the buffer ends and make sure I don't go past that.</p>
<h3>The Problem</h3>
<p>What if I do go past that? Well, I would start reading or writing data to parts of the memory that are used for other things in the program. This is a <strong>buffer overflow</strong>. This might just cause simple errors where variables are overwritten and have the wrong values. However, one of the things that a program stores in its memory is where to find the next block of code to execute. If an attacker realizes that their input is put into a buffer without any checking, they could try to deliberately write that location in the memory so that their own code would be executed instead of my code. The area of memory that contains (among other things) the address of the code to execute next is called the stack, so a buffer overflow in that area is called a <strong>stack overflow</strong> (yes, that is where the name of the website comes from).</p>
<p>Similarly, if I take as input the amount of buffer space to read and don't check that it is less than the size of the buffer, I may end up sending to an attacker private information that they shouldn't have access to. This was the cause of the infamous <a target="_blank" href="http://heartbleed.com/">Heartbleed</a> issue.</p>
<h3> The Fixes</h3>
<p>For you as a programmer, there are a number of things you can do.</p>
<ul>
<li>The main thing, our theme in this unit, is to <strong>check user input</strong>. If the user is giving you a size, check to make sure that the size is smaller than your buffer (and positive!). If the user is giving you data, only save as much as will fit in the buffer you have (or make the buffer bigger).</li>
<li><strong>Don't use a language (like C or C++) that doesn't have protections against unsafe memory access</strong> unless it is absolutely necessary.</li>
<li>When using C++, <strong>use the C++ string and vector objects</strong> rather than C-style strings and arrays, unless your code really must take up less memory or computational power (Does it <em>really </em>need that? Did you run it through a profiler?). In general <strong>prefer the C++ standard libraries</strong> to the C standard libraries.</li>
<li>When using C, <strong>always use the string/array/list functions that take a size argument</strong>. Without a size, C will keep going until it finds a null byte (that is one with value 0) marking the end of the array. If you forgot to put a null byte at the end or if it is overwritten, the C function will keep going, using parts of the memory that are not actually part of your array. The functions that take a size, in contrast, will stop when the size limit is reached. Specifically, this means you should be using <strong>strncpy</strong> instead of strcpy, <strong>strncat</strong> instead of strcat, <strong>snprintf</strong> instead of sprintf, and so on.</li>
</ul>
<p>There are also things that compilers, operating systems, and processors do to mitigate the danger from buffer overflows. The addresses for where to get the next sections of code that will be executed are usually stored on a structure called the <strong>stack</strong>. Writing a buffer overflow that overwrites these addresses is called <strong>smashing the stack</strong>. Many system-wide mitigations focus on prevent stack smashing. <a target="_blank" href="https://security.stackexchange.com/questions/20497/stack-overflows-defeating-canaries-aslr-dep-nx">This post has details about many of these and links to papers about what they can and cannot prevent</a>. Here are a few examples:</p>
<ul>
<li>
<strong>Stack canaries </strong>are special values that are added into the stack. If these values are not present (perhaps because something overwrote them), the program will not be allowed to run.</li>
<li>
<strong>Executable space protection</strong> allows part of the memory to be marked non-executable. All user input should be put in those parts. Now, even if an attacker manages to overwrite the addresses to point to their own code, it still won't run, because it is in a part of memory that is not allowed to run. This can be implemented in hardware, with the <strong>NX</strong> or <strong>non-execute </strong>bit.</li>
<li>
<strong>Address space layout randomization (ASLR) </strong>makes it harder for an attacker to reliably execute an attack that overwrites a specific part of the memory, because things will move around randomly each time.</li>
</ul>
